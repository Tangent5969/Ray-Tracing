#pragma once

// Auto-generated file. Do not edit manually.

const char* Default_vert =
    "#version 460 core\n\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec2 aTexCoords;\n\nout vec2 texCoords;\n\nvoid main() {\n\tgl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\n\ttexCoords = aTexCoords;\n}";

const char* Ray_frag =
    "#version 460 core\n\n#define pi 3.1415926f\n\n#define maxSpheres 100\n#define maxMaterials 100\n#define maxModels 100\n#define BVHStackSize 32\n\nvec4 debugValues = vec4(0);\n\nin vec2 texCoords;\nout vec4 FragColor;\nuniform sampler2D text;\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 dir;\n\tvec3 invDir;\n};\n\nstruct Material {\n\tvec3 color; // 12 \n\tfloat lightStrength; //4\n\tvec3 lightColor; // 12\n\tfloat smoothness; // 4\n\tfloat gloss; // 4\n\tbool glass; // 4\n\tfloat refraction; // 4\n\tfloat pad; // 4\n};\n\nstruct Sphere {\n\tvec3 pos; // 12\n\tfloat radius; // 4\n\tint matIndex; // 4\n\tfloat pad1; // 4\n\tfloat pad2; // 4\n\tfloat pad3; // 4\n};\n\nstruct Triangle {\n\tvec3 posA; // 12\n\tfloat pad1; // 4\n\tvec3 posB; // 12\n\tfloat pad2; // 4\n\tvec3 posC; // 12\n\tfloat pad3; // 4\n\tvec3 normA; // 12\n\tfloat pad4; // 4\n\tvec3 normB; // 12\n\tfloat pad5; // 4\n\tvec3 normC;// 12\n\tfloat pad6; // 4\n};\n\nstruct Model {\n\tmat4 transform; // 64\n\tmat4 invTransform; // 64\n\tint matIndex; // 4\n\tint startIndex; // 4\n\tint endIndex; // 4\n\tint BVHIndex; // 4\n};\n\nstruct BVHNode {\n\tvec3 min; // 12\n\tint leftIndex; // 4\n\tvec3 max; // 12\n\tint triIndex; // 4\n\tint triCount; // 4\n\tfloat pad1; // 4\n\tfloat pad2; // 4\n\tfloat pad3; // 4\n};\n\nstruct hitData {\n\tbool didHit;\n\tbool inside;\n\tfloat dist;\n\tvec3 pos;\n\tvec3 normal;\n\tMaterial mat;\n};\n\n\nlayout(std140) uniform bindPoint {\n\tmat4 model; // 64\n\tvec3 camPos; // 12\n\tfloat focus; // 4\n\tvec2 res; // 8\n\tint maxBounces; // 4\n\tint rayCount; // 4\n\tint spheresLength; // 4\n\tint modelsLength; // 4\n\tint accumulationFrame; // 4\n\tbool environmentLightFlag; // 4\n\n\tSphere spheres[maxSpheres];\n\tMaterial materials[maxMaterials];\n\tModel models[maxModels];\n};\n\nlayout(std140, binding = 1) buffer triangleSSBO {\n    Triangle triangles[];\n};\n\nlayout(std140, binding = 2) buffer nodeSSBO {\n    BVHNode nodes[];\n};\n\nlayout(std430, binding = 3) buffer triIndexSSBO {\n    int nodeTriIndex[];\n};\n\n\n// https://www.shadertoy.com/view/XlGcRh\nfloat random(inout uint seed) {\n\tseed = seed * 747796405 + 2891336453;\n\tuint result = ((seed >> ((seed >> 28) + 4)) ^ seed) * 277803737;\n\tresult = (result >> 22) ^ result;\n\treturn result / 4294967295.0;\n}\n\n\n// equal distribution across sphere\n// https://dspguide.com/ch2/6.html\nfloat randomNormalDist(inout uint seed) {\n    float angle = 2.0f * pi * random(seed);\n    float value = sqrt(-2.0f * log(random(seed)));\n    return value * cos(angle);\n}\n\n// Möller–Trumbore\nhitData triangleIntersect(Ray ray, Triangle tri) {\n\thitData hit;\n\thit.didHit = false;\n\n\tvec3 AB = tri.posB - tri.posA;\n\tvec3 AC = tri.posC - tri.posA;\n\tvec3 normal = cross(ray.dir, AC);\n\tfloat det = dot(AB, normal);\n\tfloat invDet = 1.0f / det;\n\n\t// ray parralel to triangle\n\tif (det < 0.0000001) return hit;\n\n\t// cramers rule\n\tvec3 AO = ray.origin - tri.posA;\n\tfloat u = dot(AO, normal);\n\tif (u < 0 || u > det) return hit;\n\n\tvec3 AOxAB = cross(AO, AB);\n\tfloat v = dot(ray.dir, AOxAB);\n\tif (v < 0 || u + v > det) return hit;\n\n\t// hit distance\n\tfloat t = dot(AC, AOxAB);\n\t// behind camera\n\tif (t < 0.0000001) return hit;\n\n\tu *= invDet;\n\tv *= invDet;\n\tt *= invDet;\n\t\n\thit.didHit = true;\n\thit.dist = t;\n\thit.pos = ray.origin + (ray.dir * t);\n\t//hit.normal = normalize(tri.normA * u + tri.normB * v + (1.0f - u - v) * tri.normC);\n\thit.normal = normalize((1.0f - u - v) * tri.normA + u * tri.normB + v * tri.normC);\n\n\n\treturn hit;\n};\n\nhitData sphereIntersect(Ray ray, Sphere sphere) {\n\thitData hit;\n\thit.didHit = false;\n\n\t// setting up quadratic\n\tvec3 a = sphere.pos - ray.origin;\n\tfloat b = dot(ray.dir, a);\n\tfloat c = dot(a, a) - sphere.radius * sphere.radius;\n\tfloat d = b * b - c;\n\n\t// any real roots\n\tif (d >= 0.0f) {\n\t\tfloat dist = b - sqrt(d);\n\t\t// 0.001 sets clip distance and fixes banding\n\t\tif (dist < 0.001) { \n\t\t\tdist = b + sqrt(d);\n\t\t\t// missed\n\t\t\tif (dist < 0.001) return hit;\n\t\t}\n\n\t\t// hit\n\t\thit.dist = dist;\n\t\thit.didHit = true;\n\t\thit.pos = ray.origin + (ray.dir * dist);\n\t\thit.normal = normalize(hit.pos - sphere.pos);\n\n\t\t// inside or outside sphere\n\t\tif (dot(ray.dir, hit.normal) > 0.0f) {\n\t\t\thit.normal = -hit.normal;\n\t\t\thit.inside = true;\n\t\t} else {\n\t\t\thit.inside = false;\n\t\t}\n\n\t}\n\treturn hit;\n};\n\n// slab method\n// https://tavianator.com/2022/ray_box_boundary.html\nfloat aabbIntersect(Ray ray, vec3 aabbMin, vec3 aabbMax) {\n\tfloat tmin = 0.0f;\n\tfloat tmax = 9999.0f;\n\tfor (int d = 0; d < 3; d++) {\n        float t1 = (aabbMin[d] - ray.origin[d]) * ray.invDir[d];\n        float t2 = (aabbMax[d] - ray.origin[d]) * ray.invDir[d];\n\n        tmin = max(tmin, min(min(t1, t2), tmax));\n        tmax = min(tmax, max(max(t1, t2), tmin));\n    }\n    return tmin < tmax ? tmin : 9999.0f;\n};\n\nhitData bvhIntersect(Ray ray, Model model) {\n\thitData result;\n\tresult.didHit = false;\n\tresult.dist = 9999.0f;\n\tint stack[BVHStackSize];\n\tint index = 1;\n\n\t// root node\n\tstack[0] = model.BVHIndex;\n\twhile (index > 0) {\n\t\tBVHNode node = nodes[stack[--index]];\t\t\t\t\n\n\t\t// leaf node\n\t\tif (node.triCount > 0) {\n\t\t\t// triangle intersections\n\t\t\tfor (int i = node.triIndex; i < node.triIndex + node.triCount; i++) {\n\t\t\t\thitData hit = triangleIntersect(ray, triangles[nodeTriIndex[i]]);\n\t\t\t\tif (hit.didHit) {\n\t\t\t\t\tif (hit.dist < result.dist) result = hit;\n\t\t\t\t}\n\t\t\t\t// tri tests debug\n\t\t\t\tdebugValues.y++;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// node tests debug\n\t\t\tdebugValues.x += 2;\n\n\t\t\tBVHNode left = nodes[node.leftIndex];\n\t\t\tBVHNode right = nodes[node.leftIndex + 1];\n\n\t\t\t// node intersections\n\t\t\tfloat leftDist = aabbIntersect(ray, left.min, left.max);\n\t\t\tfloat rightDist = aabbIntersect(ray, right.min, right.max);\n\n\t\t\t// closer node pushed to stack last\n\t\t\tif (leftDist > rightDist) {\n\t\t\t\tif (leftDist < result.dist) stack[index++] = node.leftIndex;\n\t\t\t\tif (rightDist < result.dist) stack[index++] = node.leftIndex + 1;\n\t\t\t} \n\t\t\telse {\n\t\t\t\tif (rightDist < result.dist) stack[index++] = node.leftIndex + 1;\n\t\t\t\tif (leftDist < result.dist) stack[index++] = node.leftIndex;\n\t\t\t}\t\n\n\t\t}\n\t}\n\n\n\treturn result;\n};\n\n\nhitData getCollision(Ray ray) {\n\thitData result;\n\tresult.didHit = false;\n\tresult.dist = 9999.0f;\n\thitData hit;\n\n\t// sphere intersections\n\tfor (int i = 0; i < spheresLength; i++) {\n\t\thit = sphereIntersect(ray, spheres[i]);\n\t\tif (hit.didHit) {\n\t\t\tif (hit.dist < result.dist) {\n\t\t\t\tresult = hit;\n\t\t\t\tresult.mat = materials[spheres[i].matIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\t// save ray to restore from model space\n\tvec3 originalOrigin = ray.origin;\n\tvec3 originalDir = ray.dir;\n\n\n\t// model (bvh & triangle) intersections\n\tfor (int i = 0; i < modelsLength; i++) {\n\t\tModel model = models[i];\n\n\t\t// transform ray to model space\n\t\tray.origin = (model.invTransform * vec4(originalOrigin, 1.0f)).xyz;\n\t\tray.dir = (model.invTransform * vec4(originalDir, 0.0f)).xyz;\n\t\tray.invDir = 1.0f / ray.dir;\n\n\t\tif (aabbIntersect(ray, nodes[model.BVHIndex].min, nodes[model.BVHIndex].max) > result.dist)\n\t\t\tcontinue;\n\n\t\thit = bvhIntersect(ray, model);\n\t\tif (hit.dist < result.dist) {\n\t\t\tresult = hit;\n\n\t\t\t// transform result to world space\n\t\t\tresult.pos = originalOrigin + originalDir * result.dist;\n\t\t\tresult.normal = normalize((model.transform * vec4(hit.normal, 0.0f)).xyz);\n\n\t\t\tresult.mat = materials[model.matIndex];\n\t\t}\n\t}\n\n\t// restore ray back to world space\n\tray.dir = originalDir;\n\n\treturn result;\n};\n\n\nvec3 randBounce(vec3 normal, inout uint seed) {\n\tvec3 bounce = vec3(1.0f);\n\tbounce.x = randomNormalDist(seed);\n\tbounce.y = randomNormalDist(seed);\n\tbounce.z = randomNormalDist(seed);\n\n\t// same hemisphere\n\treturn normalize(bounce) * sign(dot(normal, bounce));\n};\n\n\nvec3 reflectRay(vec3 dir, vec3 normal) {\n\treturn normalize(dir - 2.0f * dot(normal, dir) * normal);\n};\n\n\nvec3 environmentLight(Ray ray) {\n\treturn vec3(0.4, 0.5, 0.9) * (ray.dir.y + 0.95);\n}\n\n\n// snells law, gives refracted angle\nvec3 snells(vec3 dir, vec3 normal, float index, float cosine) {\n\tfloat value = 1 - index * index * (1 - cosine * cosine);\n\t// reflect\n\tif (value < 0.0f) return vec3(0);\n\t// refract\n\treturn index * dir - (index * cosine - sqrt(value)) * normal;\n}\n\n\n// Schlicks approximation\nfloat fresnel(float index, float cosine) {\n        float r0 = (1 - index) / (1 + index);\n        r0 = r0 * r0;\n        return r0 + (1 - r0) * pow(1 - cosine, 5);\n}\n\n\nvec3 trace(Ray ray, inout uint seed) {\n\tvec3 color = vec3(1.0f);\n\tvec3 light = vec3(0.0f);\n\thitData hit;\n\n\tfor (int i = 0; i <= maxBounces; i++) {\n\t\thit = getCollision(ray);\n\t\tif (hit.didHit) {\n\t\t\tMaterial mat = hit.mat;\n\n\t\t\tray.origin = hit.pos;\n\n\t\t\t// transparent\n\t\t\tif (mat.glass) {\n\t\t\t\tfloat index = hit.inside ? 1.0f / mat.refraction : mat.refraction;\n\t\t\t\tfloat cosine = dot(-ray.dir, hit.normal);\n\t\t\t\tvec3 refractDir = snells(ray.dir, hit.normal, index, cosine);\n\t\t\t\tif (refractDir == 0 || fresnel(index, cosine) > random(seed)) ray.dir = reflectRay(ray.dir, hit.normal);\n\t\t\t\telse ray.dir = refractDir;\n\t\t\t\t// blur\n\t\t\t\tray.dir += (1 - mat.smoothness) * randBounce(hit.normal, seed);\n\t\t\t}\n\n\t\t\t// matt and reflective\n\t\t\telse {\n\t\t\t\tvec3 diffuseDir = randBounce(hit.normal, seed);\n\t\t\t\t// chance of diffuse or specular reflection\n\t\t\t\tif (random(seed) >= mat.gloss) ray.dir = diffuseDir;\n\t\t\t\t// specular reflection / blur\n\t\t\t\telse ray.dir = mat.smoothness * reflectRay(ray.dir, hit.normal) + (1 - mat.smoothness) * diffuseDir;\n\t\t\t}\n\n\t\t\t// light\n\t\t\tvec3 emmited = mat.lightColor * mat.lightStrength;\n\t\t\tlight += emmited * color;\n\t\t\tcolor *= mat.color * dot(hit.normal, ray.dir);\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tif (environmentLightFlag) {\n\t\t\t\tlight += environmentLight(ray) * color;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn light;\n};\n\t\n\nvoid main() {\n\tuint seed = uint((gl_FragCoord.y * res.x) + gl_FragCoord.x) + accumulationFrame * 20983476; // large arbitrary  number \n\tfloat x = -res.x / 2.0f + gl_FragCoord.x;\n\tfloat y = -res.y / 2.0f + gl_FragCoord.y;\n\t\n\tRay ray;\n\tray.origin = camPos;\n\tray.dir = normalize(vec3(x, y, focus));\n\tray.dir = (model * vec4(ray.dir, 1.0f)).xyz;\n\t\n\tvec3 totalLight = vec3(0);\n\n\tfor (int i = 0; i < rayCount; i++) {\n\t\ttotalLight += trace(ray, seed);\n\t}\n\ttotalLight /= rayCount;\n\n\t// pixel accumulation from previous frames\n\tfloat weight = 1.0f / accumulationFrame;\n\ttotalLight = (1.0f - weight) * texture(text, texCoords).xyz + totalLight * weight;\n\t\n\t// final output color\n\t//FragColor = vec4(totalLight, 1.0f);\n\tFragColor = vec4(debugValues.x / 300.0f, debugValues.y / 100.0f, 0.0f, 1.0f);\n};";

