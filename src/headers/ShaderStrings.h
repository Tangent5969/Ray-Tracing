#pragma once

// Auto-generated file. Do not edit manually.

const char* Default_vert =
    "#version 460 core\n\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec2 aTexCoords;\n\nout vec2 texCoords;\n\nvoid main() {\n\tgl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\n\ttexCoords = aTexCoords;\n}";

const char* Ray_frag =
    "#version 460 core\n\n#define pi 3.1415926f\n#define epsilon 0.001f // prevents divide by 0\n\n#define maxSpheres 100\n#define maxMaterials 100\n\nin vec2 texCoords;\nout vec4 FragColor;\n\nuniform int rayCount;\nuniform int maxBounces;\nuniform vec3 camPos;\nuniform mat4 model;\nuniform vec2 res;\nuniform float focus;\nuniform int spheresLength;\nuniform sampler2D text;\nuniform int accumulationFrame;\nuniform bool environmentLightFlag;\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Material {\n\tvec3 color; // 12 \n\tfloat lightStrength; //4\n\tvec3 lightColor; // 12\n\tfloat smoothness; // 4\n\tfloat gloss; // 4\n\tbool glass; // 4\n\tfloat refraction; // 4\n\tfloat pad; // 4\n};\n\nstruct Sphere {\n\tvec3 pos; // 12\n\tfloat radius; // 4\n\tint matIndex; // 4\n\tfloat pad1; // 4\n\tfloat pad2; // 4\n\tfloat pad3; // 4\n};\n\nstruct Triangle {\n\tvec3 posA;\n\tfloat pad1;\n\tvec3 posB;\n\tfloat pad2;\n\tvec3 posC;\n\tfloat pad3;\n\tvec3 normA;\n\tfloat pad4;\n\tvec3 normB;\n\tfloat pad5;\n\tvec3 normC;\n\tint matIndex;\n\n};\n\nstruct hitData {\n\tbool didHit;\n\tbool inside;\n\tfloat dist;\n\tvec3 pos;\n\tvec3 normal;\n\tMaterial mat;\n};\n\n\nlayout(std140) uniform objects {\n\tSphere spheres[maxSpheres];\n\tMaterial materials[maxMaterials];\n};\n\nlayout(std140, binding = 1) buffer ssbo {\n    Triangle triangles[];\n};\n\n\n// https://www.shadertoy.com/view/XlGcRh\nfloat random(inout uint seed) {\n\tseed = seed * 747796405 + 2891336453;\n\tuint result = ((seed >> ((seed >> 28) + 4)) ^ seed) * 277803737;\n\tresult = (result >> 22) ^ result;\n\treturn result / 4294967295.0;\n}\n\n\n// equal distribution across sphere\n// https://dspguide.com/ch2/6.html\nfloat randomNormalDist(inout uint seed) {\n    float angle = 2.0f * pi * random(seed);\n    float value = sqrt(-2.0f * log(random(seed)));\n    return value * cos(angle);\n}\n\n// Möller–Trumbore\nhitData triangleIntersect(Ray ray, Triangle tri) {\n\thitData hit;\n\thit.didHit = false;\n\n\tvec3 AB = tri.posB - tri.posA;\n\tvec3 AC = tri.posC - tri.posA;\n\tvec3 normal = cross(ray.dir, AC);\n\tfloat det = dot(AB, normal);\n\n\t// ray parralel to triangle\n\tif (det < epsilon) return hit;\n\n\t// cramers rule\n\tvec3 AO = ray.origin - tri.posA;\n\tfloat u = dot(AO, normal);\n\tif (u < 0 || u > det) return hit;\n\n\tvec3 AOxAB = cross(AO, AB);\n\tfloat v = dot(ray.dir, AOxAB);\n\tif (v < 0 || u + v > det) return hit;\n\n\t// hit distance\n\tfloat t = dot(AC, AOxAB);\n\t// behind camera\n\tif (t < epsilon) return hit;\n\n\tu /= det;\n\tv /= det;\n\tt /= det;\n\t\n\thit.didHit = true;\n\thit.dist = t;\n\thit.pos = ray.origin + (ray.dir * t);\n\thit.normal = normalize(normal * u + normal * v + (1.0f - u - v) * normal);\n\treturn hit;\n};\n\nhitData sphereIntersect(Ray ray, Sphere sphere) {\n\thitData hit;\n\thit.didHit = false;\n\n\t// setting up quadratic\n\tvec3 a = sphere.pos - ray.origin;\n\tfloat b = dot(ray.dir, a);\n\tfloat c = dot(a, a) - sphere.radius * sphere.radius;\n\tfloat d = b * b - c;\n\n\t// any real roots\n\tif (d >= 0.0f) {\n\t\tfloat dist = b - sqrt(d);\n\t\t// epsilon sets clip distance and fixes banding\n\t\tif (dist < epsilon) { \n\t\t\tdist = b + sqrt(d);\n\t\t\t// missed\n\t\t\tif (dist < epsilon) return hit;\n\t\t}\n\n\t\t// hit\n\t\thit.dist = dist;\n\t\thit.didHit = true;\n\t\thit.pos = ray.origin + (ray.dir * dist);\n\t\thit.normal = normalize(hit.pos - sphere.pos);\n\n\t\t// inside or outside sphere\n\t\tif (dot(ray.dir, hit.normal) > 0.0f) {\n\t\t\thit.normal = -hit.normal;\n\t\t\thit.inside = true;\n\t\t} else {\n\t\t\thit.inside = false;\n\t\t}\n\n\t}\n\treturn hit;\n};\n\n\nhitData getCollision(Ray ray) {\n\thitData result;\n\tresult.didHit = false;\n\tresult.dist = 9999.0f;\n\thitData hit;\n\n\tfor (int i = 0; i < spheresLength; i++) {\n\t\thit = sphereIntersect(ray, spheres[i]);\n\t\tif (hit.didHit) {\n\t\t\tif (hit.dist < result.dist) {\n\t\t\t\tresult = hit;\n\t\t\t\tresult.mat = materials[spheres[i].matIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\t// add triangle detection\n\tfor (int i = 0; i < triangles.length(); i++) {\n\t\thit = triangleIntersect(ray, triangles[i]);\n\t\tif (hit.didHit) {\n\t\t\tif (hit.dist < result.dist) {\n\t\t\t\tresult = hit;\n\t\t\t\tresult.mat = materials[triangles[i].matIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn result;\n};\n\n\nvec3 randBounce(vec3 normal, inout uint seed) {\n\tvec3 bounce = vec3(1.0f);\n\tbounce.x = randomNormalDist(seed);\n\tbounce.y = randomNormalDist(seed);\n\tbounce.z = randomNormalDist(seed);\n\n\t// same hemisphere\n\treturn normalize(bounce) * sign(dot(normal, bounce));\n};\n\n\nvec3 reflectRay(vec3 dir, vec3 normal) {\n\treturn normalize(dir - 2.0f * dot(normal, dir) * normal);\n};\n\n\nvec3 environmentLight(Ray ray) {\n\treturn vec3(0.4, 0.5, 0.9) * (ray.dir.y + 0.95);\n}\n\n\n// snells law, gives refracted angle\nvec3 snells(vec3 dir, vec3 normal, float index, float cosine) {\n\tfloat value = 1 - index * index * (1 - cosine * cosine);\n\t// reflect\n\tif (value < 0.0f) return vec3(0);\n\t// refract\n\treturn index * dir - (index * cosine - sqrt(value)) * normal;\n}\n\n\n// Schlicks approximation\nfloat fresnel(float index, float cosine) {\n        float r0 = (1 - index) / (1 + index);\n        r0 = r0 * r0;\n        return r0 + (1 - r0) * pow(1 - cosine, 5);\n}\n\n\nvec3 trace(Ray ray, inout uint seed) {\n\tvec3 color = vec3(1.0f);\n\tvec3 light = vec3(0.0f);\n\thitData hit;\n\n\tfor (int i = 0; i <= maxBounces; i++) {\n\t\thit = getCollision(ray);\n\t\tif (hit.didHit) {\n\t\t\tMaterial mat = hit.mat;\n\n\t\t\tray.origin = hit.pos;\n\n\t\t\t// transparent\n\t\t\tif (mat.glass) {\n\t\t\t\tfloat index = hit.inside ? 1.0f / mat.refraction : mat.refraction;\n\t\t\t\tfloat cosine = dot(-ray.dir, hit.normal);\n\t\t\t\tvec3 refractDir = snells(ray.dir, hit.normal, index, cosine);\n\t\t\t\tif (refractDir == 0 || fresnel(index, cosine) > random(seed)) ray.dir = reflectRay(ray.dir, hit.normal);\n\t\t\t\telse ray.dir = refractDir;\n\t\t\t\t// blur\n\t\t\t\tray.dir += (1 - mat.smoothness) * randBounce(hit.normal, seed);\n\t\t\t}\n\n\t\t\t// matt and reflective\n\t\t\telse {\n\t\t\t\tvec3 diffuseDir = randBounce(hit.normal, seed);\n\t\t\t\t// chance of diffuse or specular reflection\n\t\t\t\tif (random(seed) >= mat.gloss) ray.dir = diffuseDir;\n\t\t\t\t// specular reflection / blur\n\t\t\t\telse ray.dir = mat.smoothness * reflectRay(ray.dir, hit.normal) + (1 - mat.smoothness) * diffuseDir;\n\t\t\t}\n\n\t\t\t// light\n\t\t\tvec3 emmited = mat.lightColor * mat.lightStrength;\n\t\t\tlight += emmited * color;\n\t\t\tcolor *= mat.color * dot(hit.normal, ray.dir);\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tif (environmentLightFlag) {\n\t\t\t\tlight += environmentLight(ray) * color;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn light;\n};\n\t\n\nvoid main() {\n\tuint seed = uint((gl_FragCoord.y * res.x) + gl_FragCoord.x) + accumulationFrame * 20983476; // large arbitrary  number \n\tfloat x = -res.x / 2.0f + gl_FragCoord.x;\n\tfloat y = -res.y / 2.0f + gl_FragCoord.y;\n\t\n\tRay ray;\n\tray.origin = camPos;\n\tray.dir = normalize(vec3(x, y, focus));\n\tray.dir = (model * vec4(ray.dir, 1.0f)).xyz;\n\t\n\tvec3 totalLight = vec3(0);\n\n\tfor (int i = 0; i < rayCount; i++) {\n\t\ttotalLight += trace(ray, seed);\n\t}\n\ttotalLight /= rayCount;\n\n\t// pixel accumulation from previous frames\n\tfloat weight = 1.0f / accumulationFrame;\n\ttotalLight = (1.0f - weight) * texture(text, texCoords).xyz + totalLight * weight;\n\t\n\t// final output color\n\tFragColor = vec4(totalLight, 1.0f);\n};";

